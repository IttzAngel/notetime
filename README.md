- a collection is like a container that can have zero, one, or many elements in it
- arrays are not easy or convenient to code against
- arrays can be difficult to debug because they do not have a human readable toString implementation
- you can pass System.out.println(Arrays.toString(products)); just to read it, otherwise it will not be readable
- arrays are not resizable
- collections are a lot more flexible than arrays
- arrays support duplicates, which generally you do not want
- arrays are a low level construct, they are good for basic coding, but can only go so far
- data structures are diverse, can have ordering, pairs, and uniqueness
- lists: collections with iteration order
- maps: collections of pairs
- collections framework top interface is a collection interface
- most used collection is a List, which is a list that has ordering of elements, and each element has a given index
- Set, SortedSet, and NavigableSet interfaces. Set has uniqueness as a key property
- Queue and double ended queue(Deque) interfaces. Can use first in first out, last in last out, etc
- Map and SortedMap extension, map is a collection of pairs
- each collection has at least two different components
- most popular implementations of List is ArrayList and LinkedList
- most popular implementations of sets are HashSets and TreeSets, TreeSet is a SortedSet
- most popular implementations of QUeues are PriorityQueue and LinkedList and ArrayDeque, the latter two are Deque.
- for map, we have HashMap, and for SortedMap, we have TreeMap
- to figure out which one to use, first figure out:
- are your elements keyed or just elements on their own?
- if yes, is order important?
- if yes, use SortedMap. if no, use Map
- if elements are not keyed, do the elements have to be unique?
- if yes, is order important?
- if yes, use SortedSet. if no, use Set
- if the elements do not have to be unique, does insertion order matter?
- if yes, use Deque, if no, use List
- collection interface extends the Iterable interface
- iterable interface allows us to create an object called iterator, which we can use to loop over elements in a collection
- first set of operations that collections have in common are: size(), isEmpty(), add(), and addAll()
- size() gets the number of elements in the collection
- isEmpty() returns true if size() == 0, false otherwise
- add() ensure that an element is in the collection
- addAll() adds all elements of the argument collection to this collection
- remove(element) removes the element from this collection
- removeAll(collection) removes all the elements of the argument collection to this collection
- retainAll(collection) removes all the elements of this collection not in the argument collection
- contains(element) true if the element is in this collection, false otherwise
- containsAll(collection) true if all the elements of the argument collection are in this collection
- clear() remove all elements from this collection
- easiest way to loop through a collection is to use forEach loop
- for each product in the products collection, then specify type
- reads as for(Product product : products)
- when printing use what is right before the :
- for example, this one would be System.out.println(product);
- can remove elements by using what is in the object
- for example: if(product.getWeight() > 20) {products.remove(product)}
- you cannot use add or remove or modify a collection while looping through it with foreach, it must be before or after
- to modify while looping, you can use the .iterator() that every collection has since it extends the iterable interface and has ab iterator associated with it
- example of iterator format: while(iterator.hasNext()) {Product product = iterator.next();
- if(product.getWeight() > 20 )
- {iterator.remove();}
- System.out.println(products.size());
- System.out.println(products.isEmpty());
- System.out.println(products.conatains(window));
- System.out.println(products.remove(window));
- System.out.println(products.contains(window));}}
- this would return 3, false, true, true, false (true at first for window, it gets removed, then it is no longer there thus the false)
- java collections are useful and versatile
- Lists are collections with iteration order
- first element in a list is always 0
- we can modify Lists using indices
- addAll is bulk update
- replaceAll can replace all elements in a list
- when running a test, run all previous tests to make sure nothing is broken
- make your collections private so that they wont be accessible outside the class
- sort method can sort by how you want, this example was by weight
- ArrayList is a list implementation with a backing array
- ArrayList is very convenient
- you can provide an initial capacity for backing array in an ArrayList
- majority of the time you wont do this, however default size is 10
- when going past the capacity, the size doubles, this is called growing
- ArrayList is good for general purpose
- LinkedLists are less CPU cache friendly than ArrayLists
- LinkedLists are worse than ArrayLists in most cases, they implement queue list interface, LinkedLists are good when repeatedly adding elements to the start
- LinkedLists vs ArrayLists - use in specific cases
- Both LinkedList and ArrayList have different performance tradeoffs
- Lists are very commonly used and you will see them a lot
- Maps are collections of pairs, which is a key and a value
- use Integer instead of int for map
- use .get() to return what you want, the example in the video is return idToProduct.get(id);
- V put(K key, V value)
- void putAll(Map<? etxends K, ? extends V> values)
- .put for a single value, .putAll for another Map
- null keys and values are implementation specific
- HashMap allows null key and null values
- TreeMap will allow null value but not null key
- get(Object key) looks up elements
- containsKey(Object key) and containsValue(Object value) are booleans
- you can use object for contains key
- remove(Object key) removes an object
- remember: int size() and boolean isEmpty()
- Map is the only collection that doesnt extend or implement the collection interface
- replace(key, value) updates a single value
- replaceAll(BiFunction<K, V, V>) to replace elements using a function
- remove(key, value) removes a key only if it has a value
- forEach is convenient callback based iteration
- remember to .get for Maps
- HashMap is a good general purpose implementation, TreeMap defines sort order and adds functionality
- Maps associate keys and values
- 2 key implementations
